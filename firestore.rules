rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Base rule - authenticated users can read but need specific rules to write
    match /{document=**} {
      allow read: if request.auth != null;
      allow write: if false; // Default deny write access
    }
    
    // Listings rules
    match /listings/{listingId} {
      // Basic read permission
      allow read: if true;
      
      // Allow queries on isFixedPrice field
      allow read: if request.query.limit <= 50 &&
                  request.query.filters.size() <= 4;
      
      allow create: if request.auth != null;
      // Allow ANY authenticated user to update availability status
      allow update: if request.auth != null && 
                   (resource.data.sellerId == request.auth.uid || 
                    request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isAvailable']));
      allow delete: if request.auth != null && resource.data.sellerId == request.auth.uid;
    }
    
    // Updated rules for auctions collection
    match /auctions/{auctionId} {
      // Allow reading auctions
      allow read: if true;
      
      // Allow queries with limits
      allow read: if request.query.limit <= 50 &&
                  request.query.filters.size() <= 4;
      
      // Allow creating auctions if authenticated
      allow create: if request.auth != null;
      
      // Allow updating by seller OR by bidders (only specific fields)
      allow update: if request.auth != null && (
        // Seller can update anything
        resource.data.sellerId == request.auth.uid ||
        // Bidders can only update bid-related fields
        request.resource.data.diff(resource.data).affectedKeys()
          .hasOnly(['currentPrice', 'bidCount', 'topBidderId', 'topBidderName']) &&
        request.resource.data.currentPrice > resource.data.currentPrice ||
        // Allow status updates for expired auctions
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status']) &&
         resource.data.endTime < request.time &&
         resource.data.status == 'active' &&
         request.resource.data.status == 'ended')
      );
      
      allow delete: if request.auth != null && resource.data.sellerId == request.auth.uid;
    }
    
    // Events rules - FIXED to properly allow joining events
    match /events/{eventId} {
      // Allow reading events
      allow read: if true;
      
      // Allow queries with limits
      allow read: if request.query.limit <= 50 &&
                  request.query.filters.size() <= 4;
      
      // Allow any authenticated user to create events
      allow create: if request.auth != null;
      
      // FIXED: Allow updates if user is creator OR if user is joining/leaving an event
      allow update: if request.auth != null && (
        // Creator can update anything
        resource.data.createdBy == request.auth.uid ||
        // Users can join/leave events (update attendees)
        request.resource.data.diff(resource.data).affectedKeys().hasAny(['attendees', 'currentAttendees', 'status'])
      );
      
      // Only creator can delete events
      allow delete: if request.auth != null && resource.data.createdBy == request.auth.uid;
    }
    
    // Add rules for bids collection
    match /bids/{bidId} {
      allow read: if true;
      allow create: if request.auth != null;
      allow update, delete: if request.auth != null && resource.data.bidderId == request.auth.uid;
    }
    
    // User rules
    match /users/{userId} {
      allow read: if request.auth != null;
      // Updated to allow admins to write to any user document
      allow write: if request.auth != null && (
        request.auth.uid == userId || 
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin'
      );
      
      // FIXED: Allow access to the cart subcollection
      match /cart/{itemId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }
    
    // Add rules for carts collection
    match /carts/{userId} {
      // Allow read/write for the cart owner only
      allow read, write: if request.auth != null && request.auth.uid == userId;
      
      // Allow access to items subcollection
      match /items/{itemId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }

    // Add rules for purchases collection
    match /purchases/{purchaseId} {
      allow read: if request.auth != null && 
                 (resource.data.buyerId == request.auth.uid || 
                  resource.data.sellerId == request.auth.uid);
      
      allow create: if request.auth != null;
      allow update: if request.auth != null && 
                   (resource.data.buyerId == request.auth.uid || 
                    resource.data.sellerId == request.auth.uid);
    }
    
    // UPDATED: More permissive rules for chat_rooms collection
    match /chat_rooms/{chatRoomId} {
      // Allow any authenticated user to read/write chat rooms
      allow read, write: if request.auth != null;
      
      // Allow access to messages subcollection for any authenticated user
      match /messages/{messageId} {
        allow read, write: if request.auth != null;
      }
    }
  }
} 